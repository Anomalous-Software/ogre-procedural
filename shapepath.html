<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Ogre Procedural: Shapes, paths and tracks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ogre Procedural
   &#160;<span id="projectnumber">0.3.0 unstable</span>
   </div>
   <div id="projectbrief">Procedural Geometry &amp; Textures for Ogre3D</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Shapes, paths and tracks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In <a class="elRef" doxygen="/home/pavel/workspace/ogre-git/installed/share/OGRE/docs/api/Ogre.tag:https://ogrecave.github.io/ogre/api/1.10/" href="https://ogrecave.github.io/ogre/api/1.10/namespace_ogre.html">Ogre</a> Procedural, shapes, paths and tracks all are made of line connected points.</p>
<p>The difference between them is :</p>
<ul>
<li>Tracks are 1D</li>
<li>Shapes are 2D</li>
<li>Paths are 3D</li>
</ul>
<h2>Orientation and closedness</h2>
<p>Both shapes, tracks and paths can be closed or not : if closed, there will be an automatic junction between the last point and the first point.</p>
<p>Shapes have an outside and an inside : you can define whether the left or the right side is the outside. It also makes sense with non-closed shape (for example, when extruded, the outside corresponds to where the face normal heads). There's also a function to guess where is the outside and where is the inside.</p>
<h2>Splines</h2>
<p>Splines are a few helper classes used to generate shapes or paths, by interpolating between a bunch of control points.</p>
<p>TIP: You can also generate a track by first generating a shape, then calling the method convertToTrack(). Shape's X are used as keys and Y as values.</p>
<h3>Cubic Hermite Spline</h3>
<p>This is often referred as 'Bezier Spline'. With Cubic Hermite Spline, you can choose the points and the tangents of the curves that goes through control points.</p>
<div class="image">
<img src="spline_cubichermite.png" alt="spline_cubichermite.png"/>
<div class="caption">
Figure 1. Cubic Hermite Spline</div></div>
 <div class="fragment"><div class="line">CubicHermiteSpline2().addPoint(Vector2(0,0), AT_CATMULL)</div><div class="line">                     .addPoint(Vector2(1,0), AT_CATMULL)</div><div class="line">                     .addPoint(Vector2(1,1), Vector2(0,2), Vector2(0,-2))</div><div class="line">                     .addPoint(Vector2(2,1), AT_CATMULL)</div><div class="line">                     .addPoint(2,0).addPoint(3,0)</div><div class="line">                     .addPoint(3,1).addPoint(4,1).setNumSeg(16).realizeShape()</div></div><!-- fragment --><p>You can either define the tangents of your choice, as demonstrated for the 3rd point, or auto-generate them as Catmull-Rom spline, or even straight lines.</p>
<p>See <a class="el" href="classProcedural_1_1CubicHermiteSpline2.html" title="Produces a shape from Cubic Hermite control points. ">Procedural::CubicHermiteSpline2</a> for a shape and <a class="el" href="classProcedural_1_1CubicHermiteSpline3.html" title="Produces a path from Cubic Hermite control points. ">Procedural::CubicHermiteSpline3</a> for a path.</p>
<h3>Catmull-Rom Spline</h3>
<p>It's a particular case of Cubic Hermite Spline, in which tangents are automatically calculated. Note that its the equivalent of <em><a class="elRef" doxygen="/home/pavel/workspace/ogre-git/installed/share/OGRE/docs/api/Ogre.tag:https://ogrecave.github.io/ogre/api/1.10/" href="https://ogrecave.github.io/ogre/api/1.10/class_ogre_1_1_simple_spline.html">Ogre::SimpleSpline</a></em>, and there's even a conversion function between the two.</p>
<div class="image">
<img src="spline_catmull.png" alt="spline_catmull.png"/>
<div class="caption">
Figure 2. Catmull-Rom Spline</div></div>
 <div class="fragment"><div class="line">CatmullRomSpline2().addPoint(0,0).addPoint(1,0)</div><div class="line">                   .addPoint(1,1).addPoint(2,1)</div><div class="line">                   .addPoint(2,0).addPoint(3,0)</div><div class="line">                   .addPoint(3,1).addPoint(4,1).realizeShape()</div></div><!-- fragment --><p>See <a class="el" href="classProcedural_1_1CatmullRomSpline2.html" title="Builds a shape from a Catmull-Rom Spline. ">Procedural::CatmullRomSpline2</a> for a shape and <a class="el" href="classProcedural_1_1CatmullRomSpline3.html" title="Builds a path from a Catmull-Rom Spline. ">Procedural::CatmullRomSpline3</a> for a path.</p>
<h3>Kochanek Bartels Spline</h3>
<p>Kochanek-Bartels spline is defined by control points and 3 parameters : tension, bias and continuity.</p>
<p>Here's a description of what they do :</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>+1 </th><th>-1  </th></tr>
<tr>
<td>Tension </td><td>Tight </td><td>Round </td></tr>
<tr>
<td>Bias </td><td>Post Shoot </td><td>Pre shoot </td></tr>
<tr>
<td>Continuity </td><td>Inverted corners </td><td>Box corners </td></tr>
</table>
<div class="image">
<img src="spline_kochanekbartels.png" alt="spline_kochanekbartels.png"/>
<div class="caption">
Figure 3. Kochanek Bartels Spline</div></div>
<p> See <a class="el" href="classProcedural_1_1KochanekBartelsSpline2.html" title="Builds a shape from a Kochanek Bartels spline. ">Procedural::KochanekBartelsSpline2</a> for a shape.</p>
<h3>Rounded Corner Spline</h3>
<p>This one consists in straight lines joining the control points, with corners replaced by circle arcs.</p>
<div class="image">
<img src="spline_roundedcorner.png" alt="spline_roundedcorner.png"/>
<div class="caption">
Figure 4. Rounded Corner Spline</div></div>
<p> See <a class="el" href="classProcedural_1_1RoundedCornerSpline2.html" title="Produces a shape from Cubic Hermite control points. ">Procedural::RoundedCornerSpline2</a> for a shape and <a class="el" href="classProcedural_1_1RoundedCornerSpline3.html" title="Produces a path by rounding corners of a straight-lines path. ">Procedural::RoundedCornerSpline3</a> for a path.</p>
<h3>Bezier Curve</h3>
<p>Splines and bezier curves are a few helper classes used to generate shapes or paths, by interpolating between a bunch of control points.</p>
<p>The bezier curve is not going through all control points.</p>
<div class="image">
<img src="spline_beziercurve.png" alt="spline_beziercurve.png"/>
<div class="caption">
Figure 5. Bezier Curve</div></div>
<p> See <a class="el" href="classProcedural_1_1BezierCurve2.html" title="Builds a shape from a Bezier-Curve. ">Procedural::BezierCurve2</a> for a shape and <a class="el" href="classProcedural_1_1BezierCurve3.html" title="Builds a path from a Bezier-Curve. ">Procedural::BezierCurve3</a> for a path.</p>
<h2>Track specifics</h2>
<p>Tracks are used to represent a variable that varies along a path or a shape.</p>
<p>For that reason, the keys of the track are defined relatively to the points in the main curve.</p>
<p>There are 3 different addressing modes :</p>
<ul>
<li>AM_ABSOLUTE_LINEIC : the key represents a distance from the beginning of the curve.</li>
<li>AM_RELATIVE_LINEIC : the key represents a relative distance inside the [0;1] segment, 0 being the beginning and 1 the end of the curve.</li>
<li>AM_POINT : the key represents the index of a point in the main curve.</li>
</ul>
<div class="fragment"><div class="line">Track t = Track(Track::AM_RELATIVE_LINEIC).addKeyFrame(0,0).addKeyFrame(1.0,-1.0);</div></div><!-- fragment --><h2>Shape specifics</h2>
<h3>Primitive transformations</h3>
<p>You can do some standard transformations on you shapes.</p>
<p>As an exemple, let's say we have this shape:</p>
<div class="image">
<img src="shape_geometricsetup.png" alt="shape_geometricsetup.png"/>
<div class="caption">
Figure 6. Random shape for geometry transformation</div></div>
 <div class="fragment"><div class="line">Shape s = Shape().addPoint(0.0f, 0.0f).addPoint(-0.5f, -1.0f).addPoint(-0.75f, 1.0f).addPoint(0.0f, 0.5f);</div></div><!-- fragment --><ul>
<li>Translation</li>
</ul>
<div class="image">
<img src="shape_geometrictranslate.png" alt="shape_geometrictranslate.png"/>
<div class="caption">
Figure 7. Translation</div></div>
 <div class="fragment"><div class="line">s.translate(1, 2);</div></div><!-- fragment --><ul>
<li>Scale</li>
</ul>
<div class="image">
<img src="shape_geometricscale.png" alt="shape_geometricscale.png"/>
<div class="caption">
Figure 8. Scale</div></div>
 <div class="fragment"><div class="line">s.scale(2.0f, 2.0f);</div></div><!-- fragment --><ul>
<li>Rotation</li>
</ul>
<div class="image">
<img src="shape_geometricrotate.png" alt="shape_geometricrotate.png"/>
<div class="caption">
Figure 9. Rotation</div></div>
 <div class="fragment"><div class="line">s.rotate(<a class="codeRef" doxygen="/home/pavel/workspace/ogre-git/installed/share/OGRE/docs/api/Ogre.tag:https://ogrecave.github.io/ogre/api/1.10/" href="https://ogrecave.github.io/ogre/api/1.10/class_ogre_1_1_degree.html">Ogre::Degree</a>(45));</div></div><!-- fragment --><ul>
<li>Mirror</li>
</ul>
<div class="image">
<img src="shape_geometricmirror_point.png" alt="shape_geometricmirror_point.png"/>
<div class="caption">
Figure 10a. Mirror at a point</div></div>
 <div class="fragment"><div class="line">s.mirror(0.5f, 0.5f);</div></div><!-- fragment --><div class="image">
<img src="shape_geometricmirror_yaxis.png" alt="shape_geometricmirror_yaxis.png"/>
<div class="caption">
Figure 10b. Mirror at y axis</div></div>
 <div class="fragment"><div class="line">s.mirror(Shape::MIRROR_Y_AXIS);</div></div><!-- fragment --><h3>2D CSG</h3>
<p>You can combine shapes together in order to produce new shapes, using boolean operations. Technically, the output is a multishape, because it doesn't always resolve to a single line.</p>
<p>As an exemple, let's say we have these 2 shapes :</p>
<div class="image">
<img src="shape_booleansetup.png" alt="shape_booleansetup.png"/>
<div class="caption">
Figure 11. Random shape for geometry transformation</div></div>
 <div class="fragment"><div class="line">Shape s1 = RectangleShape().realizeShape();</div><div class="line">Shape s2 = s1;</div><div class="line">s2.translate(.5f,.5f);</div></div><!-- fragment --><p>Supported boolean operations are :</p>
<ul>
<li>Union : the result contains everything inside A plus evertyhing inside B</li>
</ul>
<div class="image">
<img src="shape_booleanunion.png" alt="shape_booleanunion.png"/>
<div class="caption">
Figure 12. Union</div></div>
 <div class="fragment"><div class="line">s1.booleanUnion(s2)</div></div><!-- fragment --><ul>
<li>Intersection : the result contains everything that is inside A and B</li>
</ul>
<div class="image">
<img src="shape_booleanintersection.png" alt="shape_booleanintersection.png"/>
<div class="caption">
Figure 13. Intersection</div></div>
 <div class="fragment"><div class="line">s1.booleanIntersection(s2)</div></div><!-- fragment --><ul>
<li>Difference : the result contains everything that is in A but not in B</li>
</ul>
<div class="image">
<img src="shape_booleandifference.png" alt="shape_booleandifference.png"/>
<div class="caption">
Figure 14. Difference</div></div>
 <div class="fragment"><div class="line">s1.booleanDifference(s2)</div></div><!-- fragment --><h3>Thicken</h3>
<p>A "thin" shape can be made "thick" by using the thicken operation.</p>
<h4>before</h4>
<div class="image">
<img src="shape_thick1.png" alt="shape_thick1.png"/>
<div class="caption">
Figure 15a. before thicken</div></div>
<div class="fragment"><div class="line">Shape s;</div><div class="line">s.addPoint(-1,-1).addPoint(0.5,0).addPoint(-0.5,0).addPoint(1,1)</div></div><!-- fragment --><h4>after</h4>
<div class="image">
<img src="shape_thick2.png" alt="shape_thick2.png"/>
<div class="caption">
Figure 15b. after thicken</div></div>
 <div class="fragment"><div class="line">s.thicken(.2f)</div></div><!-- fragment --><h2>Triangulation</h2>
<p>A constrained triangulation can be performed on a shape or a multishape. It means that points from the shape(s) are joined together to form triangles.</p>
<p>The algorithm used is Bowyer-Watson, which is an implementation of a Delaunay triangulation (Delaunay simply means that triangulation is 'best quality', ie has as few thin triangles as possible)</p>
<p>The main use of triangulation in OgreProcedural is just for extrusion tips, but you can use it for your own purposes.</p>
<div class="image">
<img src="shape_triangulation.png" alt="shape_triangulation.png"/>
<div class="caption">
Figure 16. Triangulation</div></div>
 <h2>Shape Primitives</h2>
<p>There are a couple of pre-existing shape primitives. After creation it's possible to receive a Shape object by calling realizeShape()</p>
<h3>CircleShape</h3>
<div class="image">
<img src="shape_circle.png" alt="shape_circle.png"/>
<div class="caption">
Figure 17. CircleShape</div></div>
<p> See <a class="el" href="classProcedural_1_1CircleShape.html" title="Builds a circular shape. ">Procedural::CircleShape</a></p>
<h3>EllipseShape</h3>
<div class="image">
<img src="shape_ellipse.png" alt="shape_ellipse.png"/>
<div class="caption">
Figure 18. EllipseShape</div></div>
<p> See <a class="el" href="classProcedural_1_1EllipseShape.html" title="Builds a ellipse shape. ">Procedural::EllipseShape</a></p>
<h3>RectangleShape</h3>
<div class="image">
<img src="shape_rectangle.png" alt="shape_rectangle.png"/>
<div class="caption">
Figure 19. RectangleShape</div></div>
<p> See <a class="el" href="classProcedural_1_1RectangleShape.html" title="Builds a rectangular shape. ">Procedural::RectangleShape</a></p>
<h3>TriangleShape</h3>
<div class="image">
<img src="shape_triangle.png" alt="shape_triangle.png"/>
<div class="caption">
Figure 20. TriangleShape</div></div>
<p> See <a class="el" href="classProcedural_1_1TriangleShape.html" title="Builds a triangele shape. ">Procedural::TriangleShape</a></p>
<h2>MultiShapes</h2>
<p>A MultiShape is a collection of normal shapes.</p>
<h3>TextShape</h3>
<p>Creates shapes from characters of a given text (FreeType required).</p>
<div class="image">
<img src="shape_text.png" alt="shape_text.png"/>
<div class="caption">
Figure 21. TextShape</div></div>
<p> See Procedural::TextShape</p>
<h2>Path primitives</h2>
<p>At the moment there is only one path primitive. After creation it's possible to receive a Path object by calling realizePath().</p>
<h3>HelixPath</h3>
<div class="image">
<img src="spline_helix.png" alt="spline_helix.png"/>
<div class="caption">
Figure 22. HelixPath</div></div>
<p> See <a class="el" href="classProcedural_1_1HelixPath.html" title="Produces a helix path. ">Procedural::HelixPath</a></p>
<h2>SVG</h2>
<p>It is really easy to import SVG files and extrude their shapes:</p>
<div class="fragment"><div class="line">Path p;</div><div class="line">MultiShape out;</div><div class="line">SvgLoader svg;</div><div class="line"><span class="comment">// Create extrusion path</span></div><div class="line">p.addPoint(0, 0, 0);</div><div class="line">p.addPoint(0, 50, 0);</div><div class="line"><span class="comment">// Load svg file</span></div><div class="line">svg.parseSvgFile(out, <span class="stringliteral">&quot;test.svg&quot;</span>, <span class="stringliteral">&quot;Essential&quot;</span>, 16);</div><div class="line"><span class="comment">// Extrude all shapes of file</span></div><div class="line">Extruder().setMultiShapeToExtrude(&amp;out).setExtrusionPath(&amp;p).setScale(.07).realizeMesh(<span class="stringliteral">&quot;svg&quot;</span>);</div></div><!-- fragment --><h3>Example</h3>
<p>The <code>Sample_SVG</code> project demonstrates how to load various shapes from a SVG file and extrude them. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
